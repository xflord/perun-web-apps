/**
 * Perun RPC API
 * Perun Remote Procedure Calls Application Programming Interface
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: perun@cesnet.cz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

// @ts-ignore
import { Destination } from '../model/destination';
// @ts-ignore
import { DestinationPropagationType } from '../model/destinationPropagationType';
// @ts-ignore
import { DestinationType } from '../model/destinationType';
// @ts-ignore
import { HashedGenData } from '../model/hashedGenData';
// @ts-ignore
import { InputAddDestinationToMultipleServices } from '../model/inputAddDestinationToMultipleServices';
// @ts-ignore
import { InputAddDestinationsDefinedByHostsOnFacility } from '../model/inputAddDestinationsDefinedByHostsOnFacility';
// @ts-ignore
import { InputBlockServicesOnDestinations } from '../model/inputBlockServicesOnDestinations';
// @ts-ignore
import { InputCreateService } from '../model/inputCreateService';
// @ts-ignore
import { InputCreateServicesPackage } from '../model/inputCreateServicesPackage';
// @ts-ignore
import { InputRemoveRichDestinations } from '../model/inputRemoveRichDestinations';
// @ts-ignore
import { InputUnlockServicesOnDestinations } from '../model/inputUnlockServicesOnDestinations';
// @ts-ignore
import { InputUpdateService } from '../model/inputUpdateService';
// @ts-ignore
import { InputUpdateServicesPackage } from '../model/inputUpdateServicesPackage';
// @ts-ignore
import { PerunException } from '../model/perunException';
// @ts-ignore
import { Resource } from '../model/resource';
// @ts-ignore
import { RichDestination } from '../model/richDestination';
// @ts-ignore
import { Service } from '../model/service';
// @ts-ignore
import { ServiceForGUI } from '../model/serviceForGUI';
// @ts-ignore
import { ServicesPackage } from '../model/servicesPackage';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class ServicesManagerService {
  protected basePath = 'https://api-dev.perun-aai.org/ba/rpc';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration,
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach(
          (elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)),
        );
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k,
            )),
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * Adds an destination for a facility and service. If destination doesn\&#39;t exist it will be created.
   * InvalidDestinationException is thrown when destination value is invalid in given destination type.
   * @param service id of Service
   * @param facility id of Facility
   * @param destination Destination\&#39;s destination, usually a DNS name
   * @param type Destination\&#39;s type
   * @param propagationType Destination\&#39;s propagationType
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Destination>;
  public addDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Destination>>;
  public addDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Destination>>;
  public addDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling addDestination.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling addDestination.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling addDestination.',
      );
    }
    if (type === null || type === undefined) {
      throw new Error('Required parameter type was null or undefined when calling addDestination.');
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (type !== undefined && type !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    }
    if (propagationType !== undefined && propagationType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>propagationType,
        'propagationType',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addDestination`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Destination>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Adds an destination for a facility and list of services. If destination doesn\&#39;t exist it will be created. InvalidDestinationException is thrown when destination value is invalid in given destination type.
   * @param InputAddDestinationToMultipleServices
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDestinationToMultipleServices(
    InputAddDestinationToMultipleServices: InputAddDestinationToMultipleServices,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Destination>;
  public addDestinationToMultipleServices(
    InputAddDestinationToMultipleServices: InputAddDestinationToMultipleServices,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Destination>>;
  public addDestinationToMultipleServices(
    InputAddDestinationToMultipleServices: InputAddDestinationToMultipleServices,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Destination>>;
  public addDestinationToMultipleServices(
    InputAddDestinationToMultipleServices: InputAddDestinationToMultipleServices,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (
      InputAddDestinationToMultipleServices === null ||
      InputAddDestinationToMultipleServices === undefined
    ) {
      throw new Error(
        'Required parameter InputAddDestinationToMultipleServices was null or undefined when calling addDestinationToMultipleServices.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/addDestination`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Destination>(requestUrl, InputAddDestinationToMultipleServices, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Add services destinations for one service. Destinations names are taken from all facility\&#39;s host hostnames.
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDestinationsDefinedByHostsOnFacilityWithFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public addDestinationsDefinedByHostsOnFacilityWithFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public addDestinationsDefinedByHostsOnFacilityWithFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public addDestinationsDefinedByHostsOnFacilityWithFacility(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling addDestinationsDefinedByHostsOnFacilityWithFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addDestinationsDefinedByHostsOnFacility/f`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Array<Destination>>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Add services destinations for list of services. Destinations names are taken from all facility\&#39;s host hostnames.
   * @param InputAddDestinationsDefinedByHostsOnFacility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDestinationsDefinedByHostsOnFacilityWithListOfServiceAndFacility(
    InputAddDestinationsDefinedByHostsOnFacility: InputAddDestinationsDefinedByHostsOnFacility,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public addDestinationsDefinedByHostsOnFacilityWithListOfServiceAndFacility(
    InputAddDestinationsDefinedByHostsOnFacility: InputAddDestinationsDefinedByHostsOnFacility,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public addDestinationsDefinedByHostsOnFacilityWithListOfServiceAndFacility(
    InputAddDestinationsDefinedByHostsOnFacility: InputAddDestinationsDefinedByHostsOnFacility,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public addDestinationsDefinedByHostsOnFacilityWithListOfServiceAndFacility(
    InputAddDestinationsDefinedByHostsOnFacility: InputAddDestinationsDefinedByHostsOnFacility,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (
      InputAddDestinationsDefinedByHostsOnFacility === null ||
      InputAddDestinationsDefinedByHostsOnFacility === undefined
    ) {
      throw new Error(
        'Required parameter InputAddDestinationsDefinedByHostsOnFacility was null or undefined when calling addDestinationsDefinedByHostsOnFacilityWithListOfServiceAndFacility.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/addDestinationsDefinedByHostsOnFacility/lists-f`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Array<Destination>>(
      requestUrl,
      InputAddDestinationsDefinedByHostsOnFacility,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Add services destinations for all services currently available on facility (assigned to all facility\&#39;s resources). Destinations names are taken from all facility\&#39;s host hostnames.
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDestinationsDefinedByHostsOnFacilityWithServiceAndFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public addDestinationsDefinedByHostsOnFacilityWithServiceAndFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public addDestinationsDefinedByHostsOnFacilityWithServiceAndFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public addDestinationsDefinedByHostsOnFacilityWithServiceAndFacility(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling addDestinationsDefinedByHostsOnFacilityWithServiceAndFacility.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling addDestinationsDefinedByHostsOnFacilityWithServiceAndFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addDestinationsDefinedByHostsOnFacility/s-f`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Array<Destination>>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Adds destination for all services defined on the facility.
   * InvalidDestinationException is thrown when destination value is invalid in given destination type.
   * @param facility id of Facility
   * @param destination string name of destination
   * @param type Destination type (host,user@host,user@host:port,url,mail,service-specific)
   * @param propagationType propagation type (PARALLEL, DUMMY - doesn\&#39;t send data)
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDestinationsForAllServicesOnFacility(
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public addDestinationsForAllServicesOnFacility(
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public addDestinationsForAllServicesOnFacility(
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public addDestinationsForAllServicesOnFacility(
    facility: number,
    destination: string,
    type: DestinationType,
    propagationType?: DestinationPropagationType,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling addDestinationsForAllServicesOnFacility.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling addDestinationsForAllServicesOnFacility.',
      );
    }
    if (type === null || type === undefined) {
      throw new Error(
        'Required parameter type was null or undefined when calling addDestinationsForAllServicesOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (type !== undefined && type !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    }
    if (propagationType !== undefined && propagationType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>propagationType,
        'propagationType',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addDestinationsForAllServicesOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Array<Destination>>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Mark the attribute as required for the service. Required attributes are requisite for Service to run. If you add attribute which has a default attribute then this default attribute will be automatically add too.
   * @param service id of Service
   * @param attributeId id of AttributeDefinition
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRequiredAttribute(
    service: number,
    attributeId: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public addRequiredAttribute(
    service: number,
    attributeId: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public addRequiredAttribute(
    service: number,
    attributeId: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public addRequiredAttribute(
    service: number,
    attributeId: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling addRequiredAttribute.',
      );
    }
    if (attributeId === null || attributeId === undefined) {
      throw new Error(
        'Required parameter attributeId was null or undefined when calling addRequiredAttribute.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (attributeId !== undefined && attributeId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>attributeId,
        'attributeId',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addRequiredAttribute`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Batch version of addRequiredAttribute.
   * @param service id of Service
   * @param attributes list of attribute ids List&lt;Integer&gt;
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public addRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public addRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public addRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling addRequiredAttributes.',
      );
    }
    if (attributes === null || attributes === undefined) {
      throw new Error(
        'Required parameter attributes was null or undefined when calling addRequiredAttributes.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (attributes) {
      attributes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'attributes[]',
        );
      });
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addRequiredAttributes`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Adds a Service to a Services Package.
   * @param servicesPackage id of ServicesPackage
   * @param service id of Service
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addServiceToServicesPackage(
    servicesPackage: number,
    service: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public addServiceToServicesPackage(
    servicesPackage: number,
    service: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public addServiceToServicesPackage(
    servicesPackage: number,
    service: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public addServiceToServicesPackage(
    servicesPackage: number,
    service: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (servicesPackage === null || servicesPackage === undefined) {
      throw new Error(
        'Required parameter servicesPackage was null or undefined when calling addServiceToServicesPackage.',
      );
    }
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling addServiceToServicesPackage.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (servicesPackage !== undefined && servicesPackage !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>servicesPackage,
        'servicesPackage',
      );
    }
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/addServiceToServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Block all services currently assigned on this destination. Newly assigned services are still allowed for propagation.
   * @param destination id of Destination
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockAllServicesOnDestinationById(
    destination: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockAllServicesOnDestinationById(
    destination: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockAllServicesOnDestinationById(
    destination: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockAllServicesOnDestinationById(
    destination: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling blockAllServicesOnDestinationById.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockAllServicesOnDestination/d`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Block all services currently assigned on this destination. Newly assigned services are still allowed for propagation.
   * @param destination string name of destination
   * @param destinationType Destination type (like host, user@host, user@host:port, email, service-specific, ...)
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling blockAllServicesOnDestinationByName.',
      );
    }
    if (destinationType === null || destinationType === undefined) {
      throw new Error(
        'Required parameter destinationType was null or undefined when calling blockAllServicesOnDestinationByName.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (destinationType !== undefined && destinationType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destinationType,
        'destinationType',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockAllServicesOnDestination/dname-dtype`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Block all services currently assigned on this facility. Newly assigned services are still allowed for propagation.
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockAllServicesOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockAllServicesOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockAllServicesOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockAllServicesOnFacility(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling blockAllServicesOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockAllServicesOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Bans Service on a destination.
   * @param service id of Service
   * @param destination id of Destination
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockServiceOnDestination(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockServiceOnDestination(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockServiceOnDestination(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockServiceOnDestination(
    service: number,
    destination: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling blockServiceOnDestination.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling blockServiceOnDestination.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockServiceOnDestination/s-d`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Bans Service on a destination.
   * @param service id of Service
   * @param destination string name of destination
   * @param destinationType Destination type (like host, user@host, user@host:port, email, service-specific, ...)
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockServiceOnDestinationWithNameAndType(
    service: number,
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockServiceOnDestinationWithNameAndType(
    service: number,
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockServiceOnDestinationWithNameAndType(
    service: number,
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockServiceOnDestinationWithNameAndType(
    service: number,
    destination: string,
    destinationType: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling blockServiceOnDestinationWithNameAndType.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling blockServiceOnDestinationWithNameAndType.',
      );
    }
    if (destinationType === null || destinationType === undefined) {
      throw new Error(
        'Required parameter destinationType was null or undefined when calling blockServiceOnDestinationWithNameAndType.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (destinationType !== undefined && destinationType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destinationType,
        'destinationType',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockServiceOnDestination/s-dname-dtype`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Bans Service on given destinations.
   * @param service id of Service
   * @param destinations list of Destination ids List&lt;Integer&gt;
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling blockServiceOnDestinations.',
      );
    }
    if (destinations === null || destinations === undefined) {
      throw new Error(
        'Required parameter destinations was null or undefined when calling blockServiceOnDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destinations) {
      destinations.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'destinations[]',
        );
      });
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockServiceOnDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Bans service on a facility.
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockServiceOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockServiceOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockServiceOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockServiceOnFacility(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling blockServiceOnFacility.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling blockServiceOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockServiceOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Bans the Service on the destination - each pair defined by the rich destination.
   * @param InputBlockServicesOnDestinations
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockServicesOnDestinations(
    InputBlockServicesOnDestinations: InputBlockServicesOnDestinations,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockServicesOnDestinations(
    InputBlockServicesOnDestinations: InputBlockServicesOnDestinations,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockServicesOnDestinations(
    InputBlockServicesOnDestinations: InputBlockServicesOnDestinations,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockServicesOnDestinations(
    InputBlockServicesOnDestinations: InputBlockServicesOnDestinations,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (
      InputBlockServicesOnDestinations === null ||
      InputBlockServicesOnDestinations === undefined
    ) {
      throw new Error(
        'Required parameter InputBlockServicesOnDestinations was null or undefined when calling blockServicesOnDestinations.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/blockServicesOnDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, InputBlockServicesOnDestinations, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Bans services on a facility.
   * @param services list of Service ids List&lt;Integer&gt;
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public blockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public blockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public blockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public blockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (services === null || services === undefined) {
      throw new Error(
        'Required parameter services was null or undefined when calling blockServicesOnFacility.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling blockServicesOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (services) {
      services.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'services[]',
        );
      });
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/blockServicesOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Creates a new service.
   * @param name name
   * @param description description
   * @param script script which should be constructed like ./service_name (where anything else than [a-z,A-Z] is converted to _)
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createService(
    name: string,
    description: string,
    script: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Service>;
  public createService(
    name: string,
    description: string,
    script: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Service>>;
  public createService(
    name: string,
    description: string,
    script: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Service>>;
  public createService(
    name: string,
    description: string,
    script: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (name === null || name === undefined) {
      throw new Error('Required parameter name was null or undefined when calling createService.');
    }
    if (description === null || description === undefined) {
      throw new Error(
        'Required parameter description was null or undefined when calling createService.',
      );
    }
    if (script === null || script === undefined) {
      throw new Error(
        'Required parameter script was null or undefined when calling createService.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>name, 'name');
    }
    if (description !== undefined && description !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>description,
        'description',
      );
    }
    if (script !== undefined && script !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>script,
        'script',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/createService`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Service>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Creates a new service. Service object must contain name. Parameters desctiption, script, delay, recurrence, enabled are optional. Other parameters ignored.
   * @param InputCreateService
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createServiceWithService(
    InputCreateService: InputCreateService,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Service>;
  public createServiceWithService(
    InputCreateService: InputCreateService,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Service>>;
  public createServiceWithService(
    InputCreateService: InputCreateService,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Service>>;
  public createServiceWithService(
    InputCreateService: InputCreateService,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (InputCreateService === null || InputCreateService === undefined) {
      throw new Error(
        'Required parameter InputCreateService was null or undefined when calling createServiceWithService.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/createService`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<Service>(requestUrl, InputCreateService, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Creates a new services package.
   * @param InputCreateServicesPackage
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createServicesPackage(
    InputCreateServicesPackage: InputCreateServicesPackage,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<ServicesPackage>;
  public createServicesPackage(
    InputCreateServicesPackage: InputCreateServicesPackage,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<ServicesPackage>>;
  public createServicesPackage(
    InputCreateServicesPackage: InputCreateServicesPackage,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<ServicesPackage>>;
  public createServicesPackage(
    InputCreateServicesPackage: InputCreateServicesPackage,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (InputCreateServicesPackage === null || InputCreateServicesPackage === undefined) {
      throw new Error(
        'Required parameter InputCreateServicesPackage was null or undefined when calling createServicesPackage.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/createServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<ServicesPackage>(requestUrl, InputCreateServicesPackage, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Creates a new services package.
   * @param name name
   * @param description description
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createServicesPackageByNameAndDescription(
    name: string,
    description: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<ServicesPackage>;
  public createServicesPackageByNameAndDescription(
    name: string,
    description: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<ServicesPackage>>;
  public createServicesPackageByNameAndDescription(
    name: string,
    description: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<ServicesPackage>>;
  public createServicesPackageByNameAndDescription(
    name: string,
    description: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling createServicesPackageByNameAndDescription.',
      );
    }
    if (description === null || description === undefined) {
      throw new Error(
        'Required parameter description was null or undefined when calling createServicesPackageByNameAndDescription.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>name, 'name');
    }
    if (description !== undefined && description !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>description,
        'description',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/createServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<ServicesPackage>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Deletes a service.
   * @param service id of Service
   * @param force If true, delete entity forcefully.
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteService(
    service: number,
    force?: boolean,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public deleteService(
    service: number,
    force?: boolean,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public deleteService(
    service: number,
    force?: boolean,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public deleteService(
    service: number,
    force?: boolean,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling deleteService.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (force !== undefined && force !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>force, 'force');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/deleteService`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Deletes given services.
   * @param services list of Service ids List&lt;Integer&gt;
   * @param force If true, delete entity forcefully.
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteServices(
    services: Array<number>,
    force?: boolean,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public deleteServices(
    services: Array<number>,
    force?: boolean,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public deleteServices(
    services: Array<number>,
    force?: boolean,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public deleteServices(
    services: Array<number>,
    force?: boolean,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (services === null || services === undefined) {
      throw new Error(
        'Required parameter services was null or undefined when calling deleteServices.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (services) {
      services.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'services[]',
        );
      });
    }
    if (force !== undefined && force !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>force, 'force');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/deleteServices`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Deletes a services package.
   * @param servicesPackage id of ServicesPackage
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteServicesPackage(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public deleteServicesPackage(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public deleteServicesPackage(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public deleteServicesPackage(
    servicesPackage: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (servicesPackage === null || servicesPackage === undefined) {
      throw new Error(
        'Required parameter servicesPackage was null or undefined when calling deleteServicesPackage.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (servicesPackage !== undefined && servicesPackage !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>servicesPackage,
        'servicesPackage',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/deleteServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Forces service propagation on defined facility. Return int 1 &#x3D; true if it is possible, 0 &#x3D; false if not
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public forceServicePropagation(
    service: number,
    facility?: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<number>;
  public forceServicePropagation(
    service: number,
    facility?: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<number>>;
  public forceServicePropagation(
    service: number,
    facility?: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<number>>;
  public forceServicePropagation(
    service: number,
    facility?: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling forceServicePropagation.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/forceServicePropagation`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<number>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Forces services propagation on all facilities, where the services are defined, or just on the given facility.
   * @param services list of Service ids List&lt;Integer&gt;
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public forceServicePropagationBulk(
    services: Array<number>,
    facility?: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public forceServicePropagationBulk(
    services: Array<number>,
    facility?: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public forceServicePropagationBulk(
    services: Array<number>,
    facility?: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public forceServicePropagationBulk(
    services: Array<number>,
    facility?: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (services === null || services === undefined) {
      throw new Error(
        'Required parameter services was null or undefined when calling forceServicePropagationBulk.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (services) {
      services.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'services[]',
        );
      });
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/forceServicePropagationBulk`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get list of all destinations.
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllDestinations(
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public getAllDestinations(
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public getAllDestinations(
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public getAllDestinations(
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getDestinations/all`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Destination>>(requestUrl, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns list of all rich destinations defined for the facility.
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllRichDestinationsForFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<RichDestination>>;
  public getAllRichDestinationsForFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<RichDestination>>>;
  public getAllRichDestinationsForFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<RichDestination>>>;
  public getAllRichDestinationsForFacility(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getAllRichDestinationsForFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getAllRichDestinations/f`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<RichDestination>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns list of all rich destinations defined for the service.
   * @param service id of Service
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllRichDestinationsForService(
    service: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<RichDestination>>;
  public getAllRichDestinationsForService(
    service: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<RichDestination>>>;
  public getAllRichDestinationsForService(
    service: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<RichDestination>>>;
  public getAllRichDestinationsForService(
    service: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling getAllRichDestinationsForService.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getAllRichDestinations/s`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<RichDestination>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Lists resources assigned to service.
   * @param service id of Service
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAssignedResources(
    service: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Resource>>;
  public getAssignedResources(
    service: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Resource>>>;
  public getAssignedResources(
    service: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Resource>>>;
  public getAssignedResources(
    service: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling getAssignedResources.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getAssignedResourcesForService`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Resource>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * List all services associated with the facility (via resource).
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAssignedServices(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getAssignedServices(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getAssignedServices(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getAssignedServices(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getAssignedServices.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getAssignedServices/f`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * List all services associated with the facility and vo (via resource).
   * @param facility id of Facility
   * @param vo id of Vo
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAssignedServicesVo(
    facility: number,
    vo: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getAssignedServicesVo(
    facility: number,
    vo: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getAssignedServicesVo(
    facility: number,
    vo: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getAssignedServicesVo(
    facility: number,
    vo: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getAssignedServicesVo.',
      );
    }
    if (vo === null || vo === undefined) {
      throw new Error(
        'Required parameter vo was null or undefined when calling getAssignedServicesVo.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (vo !== undefined && vo !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>vo, 'vo');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getAssignedServices/f-v`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns a destination by its id.
   * @param id numeric id
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDestinationById(
    id: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Destination>;
  public getDestinationById(
    id: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Destination>>;
  public getDestinationById(
    id: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Destination>>;
  public getDestinationById(
    id: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getDestinationById.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (id !== undefined && id !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>id, 'id');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getDestinationById`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Destination>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns list of all destinations defined for the service and facility.
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public getDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public getDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public getDestinations(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling getDestinations.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getDestinations/s-f`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Destination>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Gets count of all destinations.
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDestinationsCount(
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<number>;
  public getDestinationsCount(
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<number>>;
  public getDestinationsCount(
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<number>>;
  public getDestinationsCount(
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getDestinationsCount`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<number>(requestUrl, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * List all destinations for all facilities which are joined by resources to the VO.
   * @param vo id of Vo
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFacilitiesDestinations(
    vo: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Destination>>;
  public getFacilitiesDestinations(
    vo: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Destination>>>;
  public getFacilitiesDestinations(
    vo: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Destination>>>;
  public getFacilitiesDestinations(
    vo: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (vo === null || vo === undefined) {
      throw new Error(
        'Required parameter vo was null or undefined when calling getFacilitiesDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (vo !== undefined && vo !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>vo, 'vo');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getFacilitiesDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Destination>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Return list of ServiceForGUI assigned on facility, (Service with \&quot;allowedOnFacility\&quot; property filled). 1 - allowed / 0 - service is service is denied.
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFacilityAssignedServicesForGUI(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<ServiceForGUI>>;
  public getFacilityAssignedServicesForGUI(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<ServiceForGUI>>>;
  public getFacilityAssignedServicesForGUI(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<ServiceForGUI>>>;
  public getFacilityAssignedServicesForGUI(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getFacilityAssignedServicesForGUI.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getFacilityAssignedServicesForGUI`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<ServiceForGUI>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Generates hashed group structure data for given service and facility.
   * @param service id of Service
   * @param facility id of Facility
   * @param consentEval if true the method will run consent eval
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getHashedDataWithGroups(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HashedGenData>;
  public getHashedDataWithGroups(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<HashedGenData>>;
  public getHashedDataWithGroups(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<HashedGenData>>;
  public getHashedDataWithGroups(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling getHashedDataWithGroups.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getHashedDataWithGroups.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (consentEval !== undefined && consentEval !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>consentEval,
        'consentEval',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getHashedDataWithGroups`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<HashedGenData>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Generates hashed hierarchical data structure for given service and facility.
   * @param service id of Service
   * @param facility id of Facility
   * @param consentEval if true the method will run consent eval
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getHashedHierarchicalData(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HashedGenData>;
  public getHashedHierarchicalData(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<HashedGenData>>;
  public getHashedHierarchicalData(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<HashedGenData>>;
  public getHashedHierarchicalData(
    service: number,
    facility: number,
    consentEval?: boolean,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling getHashedHierarchicalData.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getHashedHierarchicalData.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (consentEval !== undefined && consentEval !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>consentEval,
        'consentEval',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getHashedHierarchicalData`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<HashedGenData>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns list of all rich destinations defined for the service and facility.
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRichDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<RichDestination>>;
  public getRichDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<RichDestination>>>;
  public getRichDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<RichDestination>>>;
  public getRichDestinations(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling getRichDestinations.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getRichDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getRichDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<RichDestination>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns a service by its id.
   * @param id numeric id
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServiceById(
    id: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Service>;
  public getServiceById(
    id: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Service>>;
  public getServiceById(
    id: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Service>>;
  public getServiceById(
    id: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getServiceById.');
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (id !== undefined && id !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>id, 'id');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServiceById`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Service>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns a service by its name.
   * @param name name of entity
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServiceByName(
    name: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Service>;
  public getServiceByName(
    name: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Service>>;
  public getServiceByName(
    name: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Service>>;
  public getServiceByName(
    name: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling getServiceByName.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>name, 'name');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServiceByName`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Service>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns all services.
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServices(
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getServices(
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getServices(
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getServices(
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServices`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns list of denials for a destination.
   * @param destination id of Destination
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesBlockedOnDestination(
    destination: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getServicesBlockedOnDestination(
    destination: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getServicesBlockedOnDestination(
    destination: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getServicesBlockedOnDestination(
    destination: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling getServicesBlockedOnDestination.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesBlockedOnDestination`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns list of denials for a facility.
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesBlockedOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getServicesBlockedOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getServicesBlockedOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getServicesBlockedOnFacility(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling getServicesBlockedOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesBlockedOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Get all services with given attribute.
   * @param attributeDefinition id of AttributeDefinition
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesByAttributeDefinition(
    attributeDefinition: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getServicesByAttributeDefinition(
    attributeDefinition: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getServicesByAttributeDefinition(
    attributeDefinition: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getServicesByAttributeDefinition(
    attributeDefinition: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (attributeDefinition === null || attributeDefinition === undefined) {
      throw new Error(
        'Required parameter attributeDefinition was null or undefined when calling getServicesByAttributeDefinition.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (attributeDefinition !== undefined && attributeDefinition !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>attributeDefinition,
        'attributeDefinition',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesByAttributeDefinition`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Lists services stored in a package.
   * @param servicesPackage id of ServicesPackage
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesFromServicesPackage(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<Service>>;
  public getServicesFromServicesPackage(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<Service>>>;
  public getServicesFromServicesPackage(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<Service>>>;
  public getServicesFromServicesPackage(
    servicesPackage: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (servicesPackage === null || servicesPackage === undefined) {
      throw new Error(
        'Required parameter servicesPackage was null or undefined when calling getServicesFromServicesPackage.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (servicesPackage !== undefined && servicesPackage !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>servicesPackage,
        'servicesPackage',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesFromServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<Service>>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Gets package by id.
   * @param servicesPackage id of ServicesPackage
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesPackageById(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<ServicesPackage>;
  public getServicesPackageById(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<ServicesPackage>>;
  public getServicesPackageById(
    servicesPackage: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<ServicesPackage>>;
  public getServicesPackageById(
    servicesPackage: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (servicesPackage === null || servicesPackage === undefined) {
      throw new Error(
        'Required parameter servicesPackage was null or undefined when calling getServicesPackageById.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (servicesPackage !== undefined && servicesPackage !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>servicesPackage,
        'servicesPackage',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesPackageById`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<ServicesPackage>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Gets package by name.
   * @param name ServicesPackage name
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesPackageByName(
    name: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<ServicesPackage>;
  public getServicesPackageByName(
    name: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<ServicesPackage>>;
  public getServicesPackageByName(
    name: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<ServicesPackage>>;
  public getServicesPackageByName(
    name: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling getServicesPackageByName.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>name, 'name');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesPackageByName`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<ServicesPackage>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Returns packages.
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getServicesPackages(
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<Array<ServicesPackage>>;
  public getServicesPackages(
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<Array<ServicesPackage>>>;
  public getServicesPackages(
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<Array<ServicesPackage>>>;
  public getServicesPackages(
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/getServicesPackages`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<Array<ServicesPackage>>(requestUrl, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Is this Service denied on the destination? Return int 1 &#x3D; true - the Service is denied on the destination, 0 &#x3D; false - the Service is NOT denied on the destination
   * @param service id of Service
   * @param destination id of Destination
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public isServiceBlockedOnDestination(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<number>;
  public isServiceBlockedOnDestination(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<number>>;
  public isServiceBlockedOnDestination(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<number>>;
  public isServiceBlockedOnDestination(
    service: number,
    destination: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling isServiceBlockedOnDestination.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling isServiceBlockedOnDestination.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/isServiceBlockedOnDestination`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<number>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Is this Service denied on the facility? Return int 1 &#x3D; true - the Service is denied on the facility, 0 &#x3D; false - the Service is NOT denied on the facility
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public isServiceBlockedOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<number>;
  public isServiceBlockedOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<number>>;
  public isServiceBlockedOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<number>>;
  public isServiceBlockedOnFacility(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling isServiceBlockedOnFacility.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling isServiceBlockedOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/isServiceBlockedOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.get<number>(requestUrl, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Plans service propagation on defined facility. Return int 1 &#x3D; true if it is possible, 0 &#x3D; false if not
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public planServicePropagation(
    service: number,
    facility?: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<number>;
  public planServicePropagation(
    service: number,
    facility?: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<number>>;
  public planServicePropagation(
    service: number,
    facility?: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<number>>;
  public planServicePropagation(
    service: number,
    facility?: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling planServicePropagation.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/planServicePropagation`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<number>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Removes all destinations from a facility and service.
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeAllDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeAllDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeAllDestinations(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeAllDestinations(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeAllDestinations.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling removeAllDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeAllDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Remove all required attributes from service.
   * @param service id of Service
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeAllRequiredAttributes(
    service: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeAllRequiredAttributes(
    service: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeAllRequiredAttributes(
    service: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeAllRequiredAttributes(
    service: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeAllRequiredAttributes.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeAllRequiredAttributes`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Removes the specified destination from the facility and service.
   * @param service id of Service
   * @param facility id of Facility
   * @param destination Destination\&#39;s destination
   * @param type Destination\&#39;s type
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeDestination(
    service: number,
    facility: number,
    destination: string,
    type: DestinationType,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeDestination.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling removeDestination.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling removeDestination.',
      );
    }
    if (type === null || type === undefined) {
      throw new Error(
        'Required parameter type was null or undefined when calling removeDestination.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (type !== undefined && type !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>type, 'type');
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeDestination`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Removes the specified destinations from the facility and service.
   * @param service id of Service
   * @param facility id of Facility
   * @param destinations list of Destination ids List&lt;Integer&gt;
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeDestinations(
    service: number,
    facility: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeDestinations(
    service: number,
    facility: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeDestinations(
    service: number,
    facility: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeDestinations(
    service: number,
    facility: number,
    destinations: Array<number>,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeDestinations.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling removeDestinations.',
      );
    }
    if (destinations === null || destinations === undefined) {
      throw new Error(
        'Required parameter destinations was null or undefined when calling removeDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }
    if (destinations) {
      destinations.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'destinations[]',
        );
      });
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Removes destinations defined by list of rich destinations. Each destination is removed from the rich destination\&#39;s facility and service.
   * @param InputRemoveRichDestinations
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeDestinationsByRichDestinations(
    InputRemoveRichDestinations: InputRemoveRichDestinations,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeDestinationsByRichDestinations(
    InputRemoveRichDestinations: InputRemoveRichDestinations,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeDestinationsByRichDestinations(
    InputRemoveRichDestinations: InputRemoveRichDestinations,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeDestinationsByRichDestinations(
    InputRemoveRichDestinations: InputRemoveRichDestinations,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (InputRemoveRichDestinations === null || InputRemoveRichDestinations === undefined) {
      throw new Error(
        'Required parameter InputRemoveRichDestinations was null or undefined when calling removeDestinationsByRichDestinations.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/removeDestinationsByRichDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, InputRemoveRichDestinations, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Remove required attribute from service.
   * @param service id of Service
   * @param attributeId id of AttributeDefinition
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRequiredAttribute(
    service: number,
    attributeId: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeRequiredAttribute(
    service: number,
    attributeId: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeRequiredAttribute(
    service: number,
    attributeId: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeRequiredAttribute(
    service: number,
    attributeId: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeRequiredAttribute.',
      );
    }
    if (attributeId === null || attributeId === undefined) {
      throw new Error(
        'Required parameter attributeId was null or undefined when calling removeRequiredAttribute.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (attributeId !== undefined && attributeId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>attributeId,
        'attributeId',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeRequiredAttribute`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Remove required attributes from service.
   * @param service id of Service
   * @param attributes list of attribute ids List&lt;Integer&gt;
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeRequiredAttributes(
    service: number,
    attributes: Array<number>,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeRequiredAttributes.',
      );
    }
    if (attributes === null || attributes === undefined) {
      throw new Error(
        'Required parameter attributes was null or undefined when calling removeRequiredAttributes.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (attributes) {
      attributes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'attributes[]',
        );
      });
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeRequiredAttributes`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Removes a Service from a Services Package.
   * @param servicesPackage id of ServicesPackage
   * @param service id of Service
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeServiceFromServicesPackage(
    servicesPackage: number,
    service: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public removeServiceFromServicesPackage(
    servicesPackage: number,
    service: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public removeServiceFromServicesPackage(
    servicesPackage: number,
    service: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public removeServiceFromServicesPackage(
    servicesPackage: number,
    service: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (servicesPackage === null || servicesPackage === undefined) {
      throw new Error(
        'Required parameter servicesPackage was null or undefined when calling removeServiceFromServicesPackage.',
      );
    }
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling removeServiceFromServicesPackage.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (servicesPackage !== undefined && servicesPackage !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>servicesPackage,
        'servicesPackage',
      );
    }
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/removeServiceFromServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Erase all the possible denials on this destination.
   * @param destination id of Destination
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockAllServicesOnDestinationById(
    destination: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockAllServicesOnDestinationById(
    destination: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockAllServicesOnDestinationById(
    destination: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockAllServicesOnDestinationById(
    destination: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling unblockAllServicesOnDestinationById.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockAllServicesOnDestination/d`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Erase all the possible denials on this destination.
   * @param destination string name of destination
   * @param destinationType Destination type (like host, user@host, user@host:port, email, service-specific, ...)
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockAllServicesOnDestinationByName(
    destination: string,
    destinationType: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling unblockAllServicesOnDestinationByName.',
      );
    }
    if (destinationType === null || destinationType === undefined) {
      throw new Error(
        'Required parameter destinationType was null or undefined when calling unblockAllServicesOnDestinationByName.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (destinationType !== undefined && destinationType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destinationType,
        'destinationType',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockAllServicesOnDestination/dname-dtype`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Erase all the possible denials on this facility.
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockAllServicesOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockAllServicesOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockAllServicesOnFacility(
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockAllServicesOnFacility(
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling unblockAllServicesOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockAllServicesOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Free the denial of the Service on this destination. If the Service was banned on this destination, it will be freed. In case the Service was not banned on this destination, nothing will happen.
   * @param service id of Service
   * @param destination id of Destination
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockServiceOnDestinationById(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockServiceOnDestinationById(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockServiceOnDestinationById(
    service: number,
    destination: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockServiceOnDestinationById(
    service: number,
    destination: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling unblockServiceOnDestinationById.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling unblockServiceOnDestinationById.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockServiceOnDestination/s-d`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Free the denial of the Service on this destination. If the Service was banned on this destination, it will be freed. In case the Service was not banned on this destination, nothing will happen.
   * @param service id of Service
   * @param destination string name of destination
   * @param destinationType Destination type (like host, user@host, user@host:port, email, service-specific, ...)
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockServiceOnDestinationByName(
    service: number,
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockServiceOnDestinationByName(
    service: number,
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockServiceOnDestinationByName(
    service: number,
    destination: string,
    destinationType: string,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockServiceOnDestinationByName(
    service: number,
    destination: string,
    destinationType: string,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling unblockServiceOnDestinationByName.',
      );
    }
    if (destination === null || destination === undefined) {
      throw new Error(
        'Required parameter destination was null or undefined when calling unblockServiceOnDestinationByName.',
      );
    }
    if (destinationType === null || destinationType === undefined) {
      throw new Error(
        'Required parameter destinationType was null or undefined when calling unblockServiceOnDestinationByName.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destination !== undefined && destination !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destination,
        'destination',
      );
    }
    if (destinationType !== undefined && destinationType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>destinationType,
        'destinationType',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockServiceOnDestination/s-dname-dtype`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Free the denial of the Service on these destinations. If the Service was banned on these destinations, it will be freed. In case the Service was not banned on these destinations, nothing will happen.
   * @param service id of Service
   * @param destinations list of Destination ids List&lt;Integer&gt;
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockServiceOnDestinations(
    service: number,
    destinations: Array<number>,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling unblockServiceOnDestinations.',
      );
    }
    if (destinations === null || destinations === undefined) {
      throw new Error(
        'Required parameter destinations was null or undefined when calling unblockServiceOnDestinations.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (destinations) {
      destinations.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'destinations[]',
        );
      });
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockServiceOnDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Free the denial of the Service on this facility. If the Service was banned on this facility, it will be freed. In case the Service was not banned on this facility, nothing will happen.
   * @param service id of Service
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockServiceOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockServiceOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockServiceOnFacility(
    service: number,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockServiceOnFacility(
    service: number,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (service === null || service === undefined) {
      throw new Error(
        'Required parameter service was null or undefined when calling unblockServiceOnFacility.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling unblockServiceOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (service !== undefined && service !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>service,
        'service',
      );
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockServiceOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Free the denial of the Service on the destination - each pair defined by the rich destination.
   * @param InputUnlockServicesOnDestinations
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockServicesOnDestinations(
    InputUnlockServicesOnDestinations: InputUnlockServicesOnDestinations,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockServicesOnDestinations(
    InputUnlockServicesOnDestinations: InputUnlockServicesOnDestinations,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockServicesOnDestinations(
    InputUnlockServicesOnDestinations: InputUnlockServicesOnDestinations,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockServicesOnDestinations(
    InputUnlockServicesOnDestinations: InputUnlockServicesOnDestinations,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (
      InputUnlockServicesOnDestinations === null ||
      InputUnlockServicesOnDestinations === undefined
    ) {
      throw new Error(
        'Required parameter InputUnlockServicesOnDestinations was null or undefined when calling unblockServicesOnDestinations.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/unblockServicesOnDestinations`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, InputUnlockServicesOnDestinations, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Free the denial of the Service on this facility.
   * @param services list of Service ids List&lt;Integer&gt;
   * @param facility id of Facility
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unblockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public unblockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public unblockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public unblockServicesOnFacility(
    services: Array<number>,
    facility: number,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (services === null || services === undefined) {
      throw new Error(
        'Required parameter services was null or undefined when calling unblockServicesOnFacility.',
      );
    }
    if (facility === null || facility === undefined) {
      throw new Error(
        'Required parameter facility was null or undefined when calling unblockServicesOnFacility.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (services) {
      services.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'services[]',
        );
      });
    }
    if (facility !== undefined && facility !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>facility,
        'facility',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/urlinjsonout/servicesManager/unblockServicesOnFacility`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, null, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Updates a service.
   * @param InputUpdateService
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateService(
    InputUpdateService: InputUpdateService,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public updateService(
    InputUpdateService: InputUpdateService,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public updateService(
    InputUpdateService: InputUpdateService,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public updateService(
    InputUpdateService: InputUpdateService,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (InputUpdateService === null || InputUpdateService === undefined) {
      throw new Error(
        'Required parameter InputUpdateService was null or undefined when calling updateService.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/updateService`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, InputUpdateService, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }

  /**
   * Updates a service package.
   * @param InputUpdateServicesPackage
   * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateServicesPackage(
    InputUpdateServicesPackage: InputUpdateServicesPackage,
    useNon?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any>;
  public updateServicesPackage(
    InputUpdateServicesPackage: InputUpdateServicesPackage,
    useNon?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpResponse<any>>;
  public updateServicesPackage(
    InputUpdateServicesPackage: InputUpdateServicesPackage,
    useNon?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<HttpEvent<any>>;
  public updateServicesPackage(
    InputUpdateServicesPackage: InputUpdateServicesPackage,
    useNon: boolean = false,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json'; context?: HttpContext },
  ): Observable<any> {
    if (InputUpdateServicesPackage === null || InputUpdateServicesPackage === undefined) {
      throw new Error(
        'Required parameter InputUpdateServicesPackage was null or undefined when calling updateServicesPackage.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (BasicAuth) required
    localVarCredential = this.configuration.lookupCredential('BasicAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
    }

    // authentication (BearerAuth) required
    localVarCredential = this.configuration.lookupCredential('BearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let requestUrl = `${this.configuration.basePath}/json/servicesManager/updateServicesPackage`;
    if (useNon) {
      // replace the authentication part of url with 'non' authentication
      let helperUrl = new URL(requestUrl);
      let path = helperUrl.pathname.split('/');
      path[1] = 'non';
      helperUrl.pathname = path.join('/');
      requestUrl = helperUrl.toString();
    }
    return this.httpClient.post<any>(requestUrl, InputUpdateServicesPackage, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      reportProgress: reportProgress,
    });
  }
}
